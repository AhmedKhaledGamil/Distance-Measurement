#include "stdint.h"
#include "tm4c123gh6pm.h"
/*#define timer0_flag_portB  (*((volatile uint32_t *) (0x4003202C))) 
#define timer0_flag_clear_portB	(*((volatile uint32_t *)0x40032034))	
#define timer0_enable_portB (*((volatile uint32_t *) 0x40032010))*/

void SystemInit(){};
	
//double distance;
	

	
	
	void PortD_Init(void){  uint32_t delay;
 SYSCTL_RCGCGPIO_R |= 0x8;     // 1) D clock
  delay = 2;           // delay   
  GPIO_PORTD_LOCK_R = 0x4C4F434B;   // 2) unlock PortD PD0  
  GPIO_PORTD_CR_R = 0xCF;           // allow changes to PD0-6       
  GPIO_PORTD_AMSEL_R = 0x00;        // 3) disable analog function
  GPIO_PORTD_PCTL_R = 0x00000000;   // 4) GPIO clear bit PCTL  
  GPIO_PORTD_DIR_R = 0xCF;          // 5) PD0->PD6 output   
  GPIO_PORTD_AFSEL_R = 0x00;        // 6) no alternate function
  //GPIO_PORTF_PUR_R = 0x11;          // enable pullup resistors on PD4,PD0       
  GPIO_PORTD_DEN_R = 0xCF;          // 7) enable digital pins PD4-PD0        
}
	
	
	
	
	
void init () {
	uint32_t i ;
	//pin configurations for port F and B 
  SYSCTL_RCGCGPIO_R |= 0x2;
	i=3;
	//SYSCTL_RCGCTIMER_R |= 0x04;
	//i=55;
	//while((SYSCTL_PRGPIO_R & 0x022)!=0x22){}
	GPIO_PORTB_LOCK_R = 0x4C4F434B ;
	GPIO_PORTB_CR_R = 0x10;	
	GPIO_PORTB_AMSEL_R = 0   ;	
	GPIO_PORTB_PCTL_R = 0x00000000;
	GPIO_PORTB_DIR_R = 0x10;
	GPIO_PORTB_AFSEL_R = 0;	
	
	GPIO_PORTB_DEN_R |= 0x10  ;	
	
	}


	void delay_systick(uint32_t count)
	{
		NVIC_ST_CTRL_R = 0 ;
		NVIC_ST_RELOAD_R  = count ;  /// 1 millisecond    
		NVIC_ST_CURRENT_R  = 0 ;       // clear value in the current_r and clear the count flag
		NVIC_ST_CTRL_R = 5 ;
		while(!(NVIC_ST_CTRL_R&0x10000))
		{};
	}		
	void delay_times_systick(int times)
	{
		int i=0;
		for(i=0;i<times;i++)
		{
			delay_systick(160);
		}
	}
	
	
	int main ()
	{
		//uint32_t counts;
		//double time;
		PortD_Init();
init() ;
	while(1){
		
		GPIO_PORTD_DATA_R &= 0xffffff00;
		GPIO_PORTB_DATA_R &= 0xffffff0f;
		GPIO_PORTD_DATA_R |= 0x40;             /// PortD6 -> hundreds
		GPIO_PORTD_DATA_R |= 5;
		delay_times_systick(1);
		
	
		GPIO_PORTD_DATA_R &= 0xffffff00;
		GPIO_PORTB_DATA_R &= 0xffffff0f;
		GPIO_PORTD_DATA_R |= 0x80;             /// PortD7 -> tens
		GPIO_PORTD_DATA_R |= 6;
		delay_times_systick(1);
		

		GPIO_PORTD_DATA_R &= 0xffffff00;
		GPIO_PORTB_DATA_R &= 0xffffff0f;
		GPIO_PORTB_DATA_R |= 0x10;             /// PortB4 -> ones
			GPIO_PORTD_DATA_R |= 7;
		delay_times_systick(1);
	}



	}
	
	
	
	
	/*
	portF_init();
		
		while(1)
		{
			if((GPIO_PORTF_DATA_R & 0x11 )== 0x01)   // switch 4 is closed // switch 1 is open
					GPIO_PORTF_DATA_R = 0x02;
			else if((GPIO_PORTF_DATA_R & 0x11) == 0x10)
					GPIO_PORTF_DATA_R = 0x04;
			else if((GPIO_PORTF_DATA_R & 0x11) ==0x00)
					GPIO_PORTF_DATA_R= 0x08;
			else
					GPIO_PORTF_DATA_R= 0;
					
			
			
		}
	int count = 0 ;
		portF_init();
		
		GPIO_PORTF_DATA_R &= 0xFFFFFFF1;  // 
		//initialize_systick();
		while(1)
		{
				
			
			delay_times_systick(1,15999999);
			GPIO_PORTF_DATA_R ^= 0x02;    // Red led toggles every second
			count++;
			if(count==2 || count==4)
			{
				GPIO_PORTF_DATA_R ^= 0x04;  //  Blue led toggles every 2 seconds
			}
			if(count==4)
			{
				GPIO_PORTF_DATA_R ^= 0x08;  //  green led toggles every 4 seconds
				count=0;
			}
			
		}
	*/
	
	