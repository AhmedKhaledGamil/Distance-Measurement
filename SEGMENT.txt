#include "stdint.h"
#include "tm4c123gh6pm.h"
/*#define timer0_flag_portB  (*((volatile uint32_t *) (0x4003202C))) 
#define timer0_flag_clear_portB	(*((volatile uint32_t *)0x40032034))	
#define timer0_enable_portB (*((volatile uint32_t *) 0x40032010))*/

void SystemInit(){};
	
double distance;
	
const double _16MHz_1clock = 62.5e-9;
	
	
	void PortD_Init(void){ volatile unsigned long delay;
  SYSCTL_RCGC2_R |= 0x00000008;     // 1) D clock
  delay = SYSCTL_RCGC2_R;           // delay   
  GPIO_PORTF_LOCK_R = 0x4C4F434B;   // 2) unlock PortD PD0  
  GPIO_PORTF_CR_R = 0x7F;           // allow changes to PD0-6       
  GPIO_PORTF_AMSEL_R = 0x00;        // 3) disable analog function
  GPIO_PORTF_PCTL_R = 0x00000000;   // 4) GPIO clear bit PCTL  
  GPIO_PORTF_DIR_R = 0x7F;          // 5) PD0->PD6 output   
  GPIO_PORTF_AFSEL_R = 0x00;        // 6) no alternate function
  //GPIO_PORTF_PUR_R = 0x11;          // enable pullup resistors on PD4,PD0       
  GPIO_PORTF_DEN_R = 0x7F;          // 7) enable digital pins PD4-PD0        
}
	
	
	
	
	
void init () {
	uint32_t i ;
	//pin configurations for port F and B 
  SYSCTL_RCGCGPIO_R |= 0x22;
	i=3;
	SYSCTL_RCGCTIMER_R |= 0x04;
	i=55;
	//while((SYSCTL_PRGPIO_R & 0x022)!=0x22){}
		GPIO_PORTF_LOCK_R = 0x4C4F434B ;
		GPIO_PORTB_LOCK_R = 0x4C4F434B ;
	GPIO_PORTB_CR_R = 0x07;	
  GPIO_PORTF_CR_R = 0x1f;
	GPIO_PORTF_DIR_R = 0x06;
	GPIO_PORTB_DIR_R = 0x06;
	GPIO_PORTF_AFSEL_R = 0;
	GPIO_PORTB_AFSEL_R |= 0x01;	
	GPIO_PORTF_PCTL_R = 0;
	GPIO_PORTB_PCTL_R &= ~0x00000fff;
	GPIO_PORTB_PCTL_R |= 0x7;	
	GPIO_PORTF_PUR_R = 0 ;
	GPIO_PORTF_PDR_R = 0;
	GPIO_PORTF_DEN_R |= 0x1f ;
	GPIO_PORTB_DEN_R |= 0x07  ;	
  GPIO_PORTF_AMSEL_R = 0   ;
	GPIO_PORTB_AMSEL_R = 0   ;	
	}

uint32_t timer_init ()
	{
		uint32_t time1=0 ,time2=0,difference=0 ;
	// timer configuration for pin PF0 T0CCP0 
		
	TIMER2_CTL_R &= ~0x01;
	TIMER2_CFG_R |= 0x04;
	TIMER2_TAMR_R |= 0x17;
	TIMER2_CTL_R |= 0x0C;	
	//TIMER2_TAILR_R = 0x00010000;	
  TIMER2_CTL_R |= 1;	
		//timer0_flag_clear_portB =1 ;
		TIMER2_ICR_R |= 0x04; 
	while((TIMER2_RIS_R&0x04)==0){};
	 time1 = TIMER2_TAR_R;
	//timer0_flag_clear_portB =1 ;	
		TIMER2_ICR_R |= 0x04;
	while((TIMER2_RIS_R&0x04)==0){};
		 time2 = TIMER2_TAR_R;
		//timer0_flag_clear_portB =1 ;
	difference= (time2-time1) & 0x00ffffff ;
return difference;		
  	
}	
	void delay_systick(uint32_t count)
	{
		NVIC_ST_CTRL_R = 0 ;
		NVIC_ST_RELOAD_R  = 160 ;  /// 1 millisecond    
		NVIC_ST_CURRENT_R  = 0 ;       // clear value in the current_r and clear the count flag
		NVIC_ST_CTRL_R = 5 ;
		while(!(NVIC_ST_CTRL_R&0x10000))
		{};
	}		
	void delay_times_systick(int times)
	{
		int i=0;
		for(i=0;i<times;i++)
		{
			delay_systick(160);
		}
	}
	
	void Print_distance_to_7segment()
	{
		int ones,tens;
		int hundreds = (int)distance / 100;
		GPIO_PORTD_DATA_R &= 0xffffff00;
		GPIO_PORTB_DATA_R &= 0xffffff0f;
		GPIO_PORTD_DATA_R |= 0x40;             /// PortD6 -> hundreds
		GPIO_PORTD_DATA_R |= hundreds;
		delay_times_systick(1);

		
		tens = distance / 10;
		tens = tens % 10;
		GPIO_PORTD_DATA_R &= 0xffffff00;
		GPIO_PORTB_DATA_R &= 0xffffff0f;
		GPIO_PORTD_DATA_R |= 0x80;             /// PortD7 -> tens
		GPIO_PORTD_DATA_R |= tens;
		delay_times_systick(1);
		
		ones = (int)distance % 10;
		GPIO_PORTD_DATA_R &= 0xffffff00;
		GPIO_PORTB_DATA_R &= 0xffffff0f;
		GPIO_PORTB_DATA_R |= 0x10;             /// PortB4 -> ones
		GPIO_PORTD_DATA_R |= ones;
		delay_times_systick(1);
	}
	int main ()
	{
		uint32_t counts;
		double time;
		PortD_Init();
init() ;
	GPIO_PORTF_DATA_R = 0x00;
	while(1){
		
		//for(i=0;i<10000;i++)
	GPIO_PORTB_DATA_R |= 0x02;
	///delay 10 micro
		delay_times_systick(1);
			//for(i=0;i<10000;i++)
 	GPIO_PORTB_DATA_R &= ~0x02;
		
		
  		
	counts = timer_init();
	time= _16MHz_1clock * counts ;
	distance = (time * 34300)/2	; 
	
		Print_distance_to_7segment();
	// if(distance<20)
	 //GPIO_PORTF_DATA_R |= 0x02;
	 //else
		 //GPIO_PORTF_DATA_R = 0;
	
		//delay_times_systick(7);
	}



	}
	
	
	
	
	/*
	portF_init();
		
		while(1)
		{
			if((GPIO_PORTF_DATA_R & 0x11 )== 0x01)   // switch 4 is closed // switch 1 is open
					GPIO_PORTF_DATA_R = 0x02;
			else if((GPIO_PORTF_DATA_R & 0x11) == 0x10)
					GPIO_PORTF_DATA_R = 0x04;
			else if((GPIO_PORTF_DATA_R & 0x11) ==0x00)
					GPIO_PORTF_DATA_R= 0x08;
			else
					GPIO_PORTF_DATA_R= 0;
					
			
			
		}
	int count = 0 ;
		portF_init();
		
		GPIO_PORTF_DATA_R &= 0xFFFFFFF1;  // 
		//initialize_systick();
		while(1)
		{
				
			
			delay_times_systick(1,15999999);
			GPIO_PORTF_DATA_R ^= 0x02;    // Red led toggles every second
			count++;
			if(count==2 || count==4)
			{
				GPIO_PORTF_DATA_R ^= 0x04;  //  Blue led toggles every 2 seconds
			}
			if(count==4)
			{
				GPIO_PORTF_DATA_R ^= 0x08;  //  green led toggles every 4 seconds
				count=0;
			}
			
		}
	*/
	
	